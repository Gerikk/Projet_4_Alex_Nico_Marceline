---
title: "Projet 4"
author: "Marceline, Alexandre, Nicolas"
output:
  html_document:
    df_print: paged
    toc: yes
  pdf_document:
    toc: yes
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# Présentation

Le but de ce projet était de récolter les fichiers JSON des MOOCS et de les mettre sur une base de données Mongodb, puis les transférer vers Postgre(BDD relationnelle).
Ensuite, on devait faire une dataviz.

## Importation des données depuis les Moocs

A la base, nous avions décidé de récupérer les données depuis les moocs en utilisant Sélénium.

### Mise en place de la connection


```{r libriairies, echo=TRUE, eval=FALSE}
# Librairies pour selenuim
	
from selenium import webdriver
from requests import get
from requests.exceptions import RequestException
from contextlib import closing
from bs4 import BeautifulSoup
from pymongo import MongoClient # librairie qui va bien
import configparser, os, time, pickle, requests, pprint, json

import pandas as pd
from selenium.common.exceptions import NoSuchElementException

#Création de la liste des urls

#Lien de l'url
url = "https://www.fun-mooc.fr/"

#Mise en place de webdriver
driver = webdriver.Firefox(executable_path ='/usr/bin/geckodriver')
#driver= webdriver.Chrome(executable_path='/snap/bin/chromium.chromedriver')
# Fonction de la connection

def simple_get(url):
    """
    Se connecte a l'url, si statut = 200 retourne le contenu ( en appelant is_good_response)
    """
    try:
        with closing(get(url, stream=True)) as resp:
            if is_good_response(resp):
                return resp.content
            else:
                return None

    except RequestException as e:
        log_error('Error during requests to {0} : {1}'.format(url, str(e)))
        return None
def is_good_response(resp):
    """
    Renvoie 200 si connection a l'url
    """
    content_type = resp.headers['Content-Type'].lower()
    return (resp.status_code == 200 
            and content_type is not None 
            and content_type.find('html') > -1)
def log_error(e):
    """
    retourne l'erreur
    """
    print(e)
#driver.implicitly_wait(10)
    
```

### Accès aux premières pages (démo directe spyder)

On avait la possibilité de se connecter directement au site, et de récupérer les cookie générés.

```{r connect, echo=TRUE, eval=FALSE}

## Connexion avec mots de passe du cnf
driver.get(url)

login=driver.find_element_by_css_selector('.login-link').click()

config = configparser.ConfigParser()
login = config.read_file(open(os.path.expanduser("~/.datalab.cnf")))
config['mooc']['user']

driver.find_element_by_name("email").send_keys(config['mooc']['user'])
driver.find_element_by_name("password").send_keys(config['mooc']['password'] )
driver.find_element_by_id("submit").click()

##Acceptation des cookies et récupération
pickle.dump(driver.get_cookies() , open("cookies.pkl","wb"))
cookname=[]
cookies = pickle.load(open("cookies.pkl", "rb"))
#print(cookies)
for cook in cookies:
    print(cook['name'], ':', cook['value'])
    co=cook['name'], cook['value']
    cookname.append(co)
cookname=dict(cookname)
csrftok=(cookname.get('csrftoken'))
time.sleep(3)
driver.find_element_by_css_selector('.cookie-banner-button').click()
```

### Accès au premier cours et ouverture de toutes les pages


```{r 1er_cours, echo=TRUE, eval=FALSE}
##Accès au cours Accessibilité numérique et ouverture des discussion

driver.find_element_by_css_selector('li.course-item:nth-child(1) > div:nth-child(1) > article:nth-child(1) > section:nth-child(1) > div:nth-child(2) > h3:nth-child(1) > a:nth-child(1)').click() #Cours Python3
time.sleep(5)
driver.find_element_by_css_selector('.course-tabs > li:nth-child(6) > a:nth-child(1)').click() #1er cours de ma liste
time.sleep(2)
##Boucle pour charger les discussions d'Accessibilité numérique
chargeur = 0

while chargeur < 15:
    try:
        flop = driver.find_elements_by_css_selector('.forum-nav-thread-list')
        for flip in flop:
            try:
                print(chargeur)
                time.sleep(3)
                driver.find_element_by_css_selector('.forum-nav-load-more-link').click()
            except NoSuchElementException:
                if chargeur == None:
                    break
        chargeur += 1
    except:
         print('stop')
         pass
         break
print('Chargé!!!')
time.sleep(3)
```

### Tentative: Récupération des urls de toutes les pages

```{r urls, echo=TRUE, eval=FALSE}
time.sleep(3)
i = 0
a = str(i)

while i < 300:
    try:
        beach_balls = driver.find_elements_by_css_selector('.forum-nav-thread-list')
        i = i + 0,5
        for ball in beach_balls:
            try:
                a = str(i)
                print(a)
                desc = driver.find_element_by_css_selector('li.forum-nav-thread:nth-child('+a+') > a:nth-child(1) > div:nth-child(2) > span:nth-child(1)')#.text
                desc2 = driver.find_element_by_css_selector('li.forum-nav-thread:nth-child('+a+') > a:nth-child(1)')
#                time.sleep(5)
                desc.click() or desc2.click()
                time.sleep(4)
                urlsmooc.append(driver.current_url)
                time.sleep(4)
#                driver.find_element_by_css_selector('.forum-nav-load-more').click() or driver.find_element_by_css_selector('.forum-nav-load-more-link').click()
                 
            except NoSuchElementException:
#                print('Et galère!')
                pass
                continue
                if i == None:
                    print('Oh merde!')
                    break

#        i += 1
#        links=driver.find_element_by_class_name('forum-nav-thread-title')
    except: #exceptions.StaleElementReferenceException:
         print('Damned'+ a)
         break
access_num=driver.current_url

```

```{r envoi nmongo, echo=TRUE, eval=FALSE}
config = configparser.ConfigParser()
config.read_file(open(os.path.expanduser("~/.datalab.cnf")))

CNF = "mongo"
BDD = "Datalab"

# Ouverture connection -> mongo sur serveur
client = MongoClient('mongodb://%s:%s@%s/?authSource=%s' % (config[CNF]['user'], config[CNF]['password'], config[CNF]['host'], BDD))
print(client)

bdd = client['MOOC_GRP_MAN'] # BDD "Datalab" de mongoDB sur serveur
bdd
print("'MOOC_GRP_MAN' Collections:")
for cn in bdd.list_collection_names():
    print("-"+cn)
collec = client['MOOC_GRP_MAN']['Triss_Merigold']
cternazscie=urlsmoocAcces1[14]

#for urlsmooc in urlsmoocAcces1:
response = requests.get(
    "https://www.fun-mooc.fr/courses/course-v1:inria+41012+self_paced/discussion/forum/i4x-inria-41012S02-course-session02/threads/"+cternazscie+"?ajax=1&resp_skip=0&resp_limit=999",
    #params={'q': 'requests+language:python'},
    #headers={'Accept': 'application/vnd.github.v3.text-match+json'},
    headers={
        #"User-Agent": "Mozilla/5.0 (X11; Ubuntu; Linux i686; rv:69.0) Gecko/20100101 Firefox/69.0",
        "Accept": "application/json, text/javascript, */*; q=0.01",
        #"Accept-Language": "en-US,en;q=0.5",
        "X-CSRFToken": ""+csrftok+"", #Change à chaque fois!!!!
        "X-Requested-With": "XMLHttpRequest",
        #'Referer': 'https://www.fun-mooc.fr/courses/course-v1:MinesTelecom+04026+session05/discussion/forum/204c764cf87424d86a6259562d1d200afe30ab9a/threads/5d9481db1c89dcf269015b6f' ,
        'Cookie': 'Cookie: defaultRes=900%2C0; csrftoken='+csrftok+'; atuserid=%7B%22name%22%3A%22atuserid%22%2C%22val%22%3A%222bcd8684-307f-4536-8925-aef21cd909ff%22%2C%22options%22%3A%7B%22end%22%3A%222020-11-02T08%3A43%3A21.983Z%22%2C%22path%22%3A%22%2F%22%7D%7D; atidvisitor=%7B%22name%22%3A%22atidvisitor%22%2C%22val%22%3A%7B%22vrn%22%3A%22-602676-%22%7D%2C%22options%22%3A%7B%22path%22%3A%22%2F%22%2C%22session%22%3A15724800%2C%22end%22%3A15724800%7D%7D; sessionid=xh3lf4oa1xsdnjukvsf25zvx1scyib69; edxloggedin=true; edx-user-info="{\"username\": \"Gerikk\"\054 \"version\": 1\054 \"email\": \"alexandreblt4@gmail.com\"\054 \"header_urls\": {\"learner_profile\": \"https://www.fun-mooc.fr/u/Gerikk\"\054 \"logout\": \"https://www.fun-mooc.fr/logout\"\054 \"account_settings\": \"https://www.fun-mooc.fr/account/settings\"}}"'
    },
)
print(response)
#    print(response.content)
pprint.pprint(response.json())

collec.insert_one(response.json())



for d in response.content:
    test=response.json()


print(response.content)
pprint.pprint(response.json())
Dico=response.json()
```

## Importations

Le principal problème rencontré était le caractère chronophage de Sélénium, ainsi que les importations qui se bloquaient. Afin de pouvoir avancé, nous avons importé dans notre base MongoDB.

A la place, nous avons utilisé le dossier contenant tout les MOOCs, après importation depuis le serveur, ce qui nous a permis de progresser.

## De mongo vers Postgre

```{r applatir, echo=TRUE, eval=FALSE}
import pprint, os, pandas

from sqlalchemy import create_engine
from sqlalchemy.sql import text

from pymongo import MongoClient # librairie qui va bien
import configparser

config = configparser.ConfigParser()
config.read_file(open(os.path.expanduser("~/.datalab.cnf")))

CNF = "mongo"
BDD = "Datalab"
# Ouverture connection -> mongo sur serveur
client = MongoClient('mongodb://%s:%s@%s/?authSource=%s' % (config[CNF]['user'], config[CNF]['password'], config[CNF]['host'], BDD))
print(client)

TBL = "alex"
CNF2 = "Postgre"#"pgMB"
pgSQLengine = create_engine("postgresql://%s:%s@%s/%s" % (config[CNF2]['user'], config[CNF2]['password'], config[CNF2]['host'], "BDD_MOOC_GRP_MAN"))
print(pgSQLengine)
#pgSQLengine.execute("TRUNCATE \"%s\";" % TBL)
statement = text("""
INSERT INTO "mooc_grp_man"."alex" (id, course_id, body, date, username)
VALUES (:id, :cid, :body, :date, :username)""")
#~ exit()

bdd = client['Datalab'] # BDD "Datalab" de mongoDB sur serveur
bdd
#~ print("'Datalab' Collections:")
#~ for cn in bdd.list_collection_names():
    #~ print("-"+cn)
collec = client['MOOC_GRP_MAN']['An_infortunate_import']

NivMax = 0

def applat(mesg, niv):
    global NivMax
    l = len(mesg['body'])
    username = '?'
    if 'username' in mesg: username = mesg['username'][:50]
    #c = len(mesg['endorsed_responses']+mesg['non_endorsed_responses'])

    pgSQLengine.execute(statement, id=mesg['id'], cid=mesg['course_id'], body=mesg['body'], date=mesg['updated_at'], username=username)
    childs = [] # liste des enfants
    if 'children' in mesg: childs += mesg['children']
    if 'endorsed_responses' in mesg: childs += mesg['endorsed_responses']
    if 'non_endorsed_responses' in mesg: childs += mesg['non_endorsed_responses']
    for child in childs:
#        applat(child+l, niv+1)
        l+=applat(child,niv+1)
    #print("nombre de caractères cumulés ",l)
    if niv > NivMax:
        NivMax = niv
    print("%s %s %s : %s = %d,%d" % ("  "*niv, mesg['course_id'], mesg['updated_at'], username,len(mesg['body']),l))
    return l

cursor = collec.find()
for doc in cursor:
    if 'content' in doc:
        #~ pprint.pprint(doc)
        print("-------------------------------")
        longueur = applat(doc['content'], 0)
        #~ print(longueur)
        
print("Niv max=%d" % NivMax)

```

## De Postgre vers R

```{r base, message=FALSE, warning=FALSE}
library(tidyverse)
library(config)
library(DBI)
library(RPostgreSQL)
library(ggplot2)
#Définition du chemin du dossier config.rml (à créer avant)
conf <- config::get("Postgre", file="~/Documents/Projet_4/.config.yml", use_parent = FALSE)

#-----------------Définition des variables issues de config--------------------
user1<-conf$user
password1<-conf$password
Dt<-conf$database
host<-conf$host

#--------------URL pour connection à la base sans mot de passe--------------

drv <- dbDriver("PostgreSQL")
mydb<- dbConnect(drv, user=user1, password=password1, dbname=Dt, host=host)
DBI::dbListTables(mydb)

selection= DBI::fetch(dbSendQuery(mydb, "SELECT * FROM mooc_grp_man.nicolas2 ORDER BY date"), n=-1)

#-----------Pour la déconnection!-----------------------
dbDisconnect(mydb)


```


## Résultat final

* Près de 55801 résultats incluant
  - 185 cours différents
  - Des messages allant de 2014 à 2019


## Dataviz sous R

```{r ggplot, echo=TRUE, message=FALSE, warning=FALSE}
#----------Dataviz-----------------------------------
#Creation of a color palette with different sizes for plots
ColorschemeBG<-grDevices::colorRampPalette(colorRamps::blue2green(30))
Colours<-ColorschemeBG(100)
Col_L<-ColorschemeBG(300)
Col_S<-ColorschemeBG(6)
fillBG<-ggplot2::scale_fill_manual(values=Colours)
L_fillBG<-ggplot2::scale_fill_manual(values=Col_L)
S_fillBG<-ggplot2::scale_fill_manual(values=Col_S)
coulBG<-ggplot2::scale_color_manual(values=Colours)
L_coulBG<-ggplot2::scale_color_manual(values=Col_L)
S_coulBG<-ggplot2::scale_color_manual(values=Col_S)

#-------Plot global---------

Select2<-selection
Select2$date<-substr(Select2$date, 0, 10)
Select2$date<-as.Date(Select2$date)

Global<-ggplot(Select2) + 
  aes(x = date) +
  geom_bar(fill = "purple") +
  labs(x = "Années", y = "Nombre", title = "Vue d'ensemble des messages envoyés", subtitle = "de 2014 à 2019") +
  scale_x_date(breaks = "1 year", date_minor_breaks = "1 month", date_labels = "%Y")
Global

#-------Nombre de messages par année-------
Dates<-selection %>%
  dplyr::group_by(id, course_id, date, body, title, courseware_title, thread_type, username) %>%
  dplyr::summarise(Nombre = n())
Dates$date<-substr(Dates$date, 0, 4)


plot1<-ggplot2::ggplot(Dates)+ geom_col(aes(x= date, y=Nombre, fill=date)) + S_fillBG + ggplot2::labs(title ="Nombre de messages de 2014 à 2019", x = "Années", y="Nombre de messages")
plot1

#---------------Comparaison des nombres de questions et de discussion-------------

ggplot(selection) +
  aes(x = thread_type, fill = thread_type) +
  geom_bar() +
  scale_fill_hue() +
  scale_fill_brewer(palette = "Set1") +
  labs(title = "Comparaison des nombres de questions et de discussions", x='Type de thread', y="Nombre d'occurences", fill="Type de thread")

#----------------Nombres de questions et de discussion 2019------------------

ggplot(Select2) +
  aes(x = date, fill = thread_type) +
  geom_histogram(bins = 30L) +
  scale_fill_hue() +
  scale_fill_brewer(palette = "Set1")+
  labs(title = "Nombres de questions et de discussions", subtitle = "De 2014 à 2019", x='Type de thread', y="Nombre d'occurences", fill="Type de thread") +
  scale_x_date(breaks = "1 year", date_minor_breaks = "1 month", date_labels = "%Y")

#----Dataframes des plots

cours_questions<-selection %>%
  dplyr::group_by(course_id, thread_type) %>%
  dplyr::summarise(Nombre = n()) %>%
  filter(thread_type == 'question')

cours_discussions<-selection %>%
  dplyr::group_by(course_id, thread_type) %>%
  dplyr::summarise(Nombre = n()) %>%
  filter(thread_type == 'discussion')

Tous<-selection %>%
  dplyr::group_by(course_id, thread_type) %>%
  dplyr::summarise(Nombre = n())


#-------Combinaison top 20 question et discussions

ggplot(Tous[1:38,]) +
  aes(x = reorder(course_id, Nombre), y=Nombre, fill = thread_type) +
  geom_col() +
  coord_flip()+
  scale_fill_brewer(palette = "Set1") +
  labs(title = "Top 20 des questions et discussions par cours", x='Cours', y="Nombre d'occurences", fill="Type de thread")

#---------Plot du top 20 des discussions----------

Discussions<-ggplot2::ggplot(cours_discussions[1:20,]) +
  geom_col(aes(x = reorder(course_id, Nombre), y= Nombre, fill=Nombre))
Discussions + S_coulBG + labs(title = "Top 20 de discussions par cours", x='Cours', y="Nombre d'occurences") + coord_flip()+scale_fill_gradient(low = "red", high = "darkred")

#---------Plot du top 20 des questions----------

Questions<-ggplot2::ggplot(cours_questions[1:20,]) +
  geom_col(aes(x = reorder(course_id, Nombre), y= Nombre, fill=Nombre)) +
  scale_fill_gradient(low = "blue", high = "darkblue")
Questions + coord_polar() + S_coulBG + labs(title = "Top 20 de questions par cours", x='Cours', y="Nombre d'occurences") +  scale_x_discrete(labels = abbreviate)

```

